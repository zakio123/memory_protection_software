diff --git a/riscv/mmio_devices/aes_device.h b/riscv/mmio_devices/aes_device.h
new file mode 100644
index 00000000..dc6085ce
--- /dev/null
+++ b/riscv/mmio_devices/aes_device.h
@@ -0,0 +1,308 @@
+// #pragma once
+// #include "devices.h"
+// #include "sim.h"
+// #include "mmio_map.h"
+// #include "axim_device.h"
+// #include <vector>
+// #include <cstring>
+// #include <cstdint>
+// #include <algorithm>
+// class aes_mmio_device_t final : public abstract_device_t {
+// public:
+//   aes_mmio_device_t(sim_t* sim, axim_mmio_device_t* m_axi)
+//   : sim(sim), m_mod(m_axi) {}
+    
+//   reg_t size() override { return aes_addrmap_t::CTRL_SIZE; }
+//     // MMIO read
+//     bool load(reg_t addr, size_t len, uint8_t* bytes) override {
+//         if (len != 8) return false;
+//         uint64_t v = 0;
+//         switch (addr) {
+//             case aes_addrmap_t::REG_START:      v = m_start_reg;      break;
+//             default: return false; // 他は読み不可
+//         }
+//         std::memcpy(bytes, &v, 8);
+//         return true;
+//     }
+//     bool store(reg_t addr, size_t len, const uint8_t* bytes) override {
+//         if (len != 8) return false;
+//         uint64_t v; std::memcpy(&v, bytes, 8);
+//         if (addr >= aes_addrmap_t::REG_INPUT_0 && addr < aes_addrmap_t::REG_START) {
+//             std::memcpy(&m_input_data[(addr - aes_addrmap_t::REG_INPUT_0)], &v, sizeof(uint64_t));
+//             return true;
+//         } else if (addr == aes_addrmap_t::REG_START) {
+//             if ((v & 1) && (m_start_reg == 0)){
+//                 m_start_reg = 1;
+//                 // AES暗号化処理を開始
+//                 runOtpGeneration();
+//                 m_start_reg = 0;
+//             }
+//             return true;
+//         } else {
+//             return false; // 他は書き不可
+//         }
+//     }
+
+// private:
+//     // AESの状態 (128bit) は 4x4 のバイト行列として扱う
+//     using State = std::array<std::array<uint8_t, 4>, 4>;
+//     using Key = std::array<uint8_t, 16>;
+
+//     // 実際のAESで使われるS-box (置換テーブル)
+//     static constexpr std::array<uint8_t, 256> s_box = {
+//         0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+//         0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+//         0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+//         0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+//         0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+//         0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+//         0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+//         0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+//         0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+//         0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+//         0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+//         0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+//         0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+//         0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+//         0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+//         0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
+//     };
+
+//     // --- AESの各ステップを模倣するヘルパー関数 ---
+    
+//     // SubBytes: S-boxを使って各バイトを置換する
+//     void subBytes(State& state) {
+//         for (int i = 0; i < 4; ++i) {
+//             for (int j = 0; j < 4; ++j) {
+//                 state[i][j] = s_box[state[i][j]];
+//             }
+//         }
+//     }
+
+//     // ShiftRows: 行をサイクリックシフトする
+//     void shiftRows(State& state) {
+//         // row 1: 1 byte left shift
+//         uint8_t temp = state[1][0];
+//         state[1][0] = state[1][1]; state[1][1] = state[1][2]; state[1][2] = state[1][3]; state[1][3] = temp;
+//         // row 2: 2 bytes left shift
+//         std::swap(state[2][0], state[2][2]); std::swap(state[2][1], state[2][3]);
+//         // row 3: 3 bytes left shift
+//         temp = state[3][3];
+//         state[3][3] = state[3][2]; state[3][2] = state[3][1]; state[3][1] = state[3][0]; state[3][0] = temp;
+//     }
+
+//     // MixColumns: 列内のバイトを混合する (簡易版シミュレーション)
+//     void mixColumns_sim(State& state) {
+//         for (int j = 0; j < 4; ++j) {
+//             uint8_t t0 = state[0][j], t1 = state[1][j], t2 = state[2][j], t3 = state[3][j];
+//             state[0][j] = t0 ^ t1 ^ t2;
+//             state[1][j] = t1 ^ t2 ^ t3;
+//             state[2][j] = t2 ^ t3 ^ t0;
+//             state[3][j] = t3 ^ t0 ^ t1;
+//         }
+//     }
+    
+//     // AddRoundKey: 状態とキーでXORを取る
+//     void addRoundKey(State& state, const Key& key) {
+//         for (int i = 0; i < 4; ++i) {
+//             for (int j = 0; j < 4; ++j) {
+//                 state[j][i] ^= key[i * 4 + j];
+//             }
+//         }
+//     }
+
+//     /**
+//      * @brief 128bitブロックを暗号化するAESのメインパイプライン
+//      */
+//     axim_mmio_device_t::Otp encryptBlock(const Key& key, const axim_mmio_device_t::Otp& plaintext) {
+//         State state;
+//         // 1次元配列(plaintext)を2次元のStateに変換
+//         for(int i=0; i<16; ++i) state[i % 4][i / 4] = plaintext[i];
+
+//         addRoundKey(state, key); // ラウンド0
+
+//         // 4ラウンドの暗号化処理をシミュレート
+//         const int num_rounds = 4;
+//         for (int round = 0; round < num_rounds; ++round) {
+//             subBytes(state);
+//             shiftRows(state);
+//             if (round < num_rounds - 1) { // 最終ラウンドではMixColumnsは行わない
+//                 mixColumns_sim(state);
+//             }
+//             addRoundKey(state, key); // 簡単化のため毎回同じ鍵を使用
+//         }
+        
+//         // 2次元のStateを1次元配列に戻して返す
+//         axim_mmio_device_t::Otp ciphertext;
+//         for(int i=0; i<16; ++i) ciphertext[i] = state[i % 4][i / 4];
+//         return ciphertext;
+//     }
+//     // モジュール内部に固定で保持されるハードウェアキー
+//     static constexpr Key m_hardware_key = {
+//         0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
+//         0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
+//     };
+
+//     void runOtpGeneration() {
+//         for (int i = 0; i < 4; ++i) {
+//             axim_mmio_device_t::Otp counter_block;
+//             // m_input_dataからi番目の128bitカウンター値を抽出
+//             std::copy(m_input_data.begin() + (i * 16), 
+//                       m_input_data.begin() + ((i + 1) * 16), 
+//                       counter_block.begin());
+
+//             // 固定のハードウェアキーを使って、カウンター値を暗号化する
+//             axim_mmio_device_t::Otp otp_block = encryptBlock(m_hardware_key, counter_block);
+//             // std::cout << "  [AES HW] Encrypted counter " << i << ". Pushing result to FIFO...\n";
+//             m_mod->pushOtpToFifo(otp_block);
+//         }
+//         // std::cout << "  [AES HW] OTP generation finished. START register cleared to 0.\n";
+//     }
+//     sim_t* sim;
+//     axim_mmio_device_t* m_mod;
+//     std::array<uint8_t, 64> m_input_data;
+//     uint64_t m_start_reg = 0;
+// };
+
+#pragma once
+#include "devices.h"
+#include "sim.h"
+#include "mmio_map.h"
+#include "axim_device.h"
+#include <array>      // ★ 追加
+#include <vector>
+#include <cstring>
+#include <cstdint>
+#include <algorithm>
+
+// AES MMIO (tick駆動版)
+class aes_mmio_device_t final : public abstract_device_t {
+public:
+  aes_mmio_device_t(sim_t* sim, axim_mmio_device_t* m_axi)
+  : sim(sim), m_mod(m_axi) {
+    m_input_data.fill(0);
+  }
+
+  reg_t size() override { return aes_addrmap_t::CTRL_SIZE; }
+
+  // MMIO READ
+  bool load(reg_t addr, size_t len, uint8_t* bytes) override {
+    if (len != 8) return false;
+    uint64_t v = 0;
+    switch (addr) {
+      case aes_addrmap_t::REG_START: v = m_start_reg; break; // 0: idle, 1: busy
+      default: return false;
+    }
+    std::memcpy(bytes, &v, 8);
+    return true;
+  }
+
+  // MMIO WRITE
+  bool store(reg_t addr, size_t len, const uint8_t* bytes) override {
+    if (len != 8) return false;
+    uint64_t v; std::memcpy(&v, bytes, 8);
+
+    if (addr >= aes_addrmap_t::REG_INPUT_0 && addr < aes_addrmap_t::REG_START) {
+      // 64Bの入力ウインドウ。8Bずつコピー
+      size_t off = static_cast<size_t>(addr - aes_addrmap_t::REG_INPUT_0);
+      if (off + 8 > m_input_data.size()) return false;
+      std::memcpy(&m_input_data[off], &v, sizeof(uint64_t));
+      return true;
+    }
+    if (addr == aes_addrmap_t::REG_START) {
+      // 立ち上がりでスタート。busy中のリトライは無視
+      if ((v & 1ULL) && m_start_reg == 0) {
+        m_start_reg = 1;      // busy
+        m_block_idx = 0;      // 次 tick から処理開始
+      }
+      return true;
+    }
+    return false;
+  }
+
+  // Spikeから周期呼び出し
+  void tick(reg_t /*rtc_ticks*/) override {
+    if (m_start_reg == 0) return;          // idle
+    if (m_block_idx >= 4) {                 // 全4ブロック完了
+      m_start_reg = 0;                      // busy解除
+      return;
+    }
+
+    // 1 tick で 1ブロック分(16B)を処理 → FIFO へ push
+    axim_mmio_device_t::Otp counter_block;
+    const size_t off = static_cast<size_t>(m_block_idx * 16);
+    std::copy(m_input_data.begin() + off,
+              m_input_data.begin() + off + 16,
+              counter_block.begin());
+
+    auto otp = encryptBlock(m_hardware_key, counter_block);
+    m_mod->pushOtpToFifo(otp);
+
+    m_block_idx++;
+  }
+
+private:
+  // AES 128bit の簡易実装（前回と同じ）
+  using State = std::array<std::array<uint8_t, 4>, 4>;
+  using Key   = std::array<uint8_t, 16>;
+
+  static constexpr std::array<uint8_t, 256> s_box = {
+    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
+    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
+    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
+    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
+    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
+    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
+    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
+    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
+    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
+    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
+    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
+    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
+    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
+    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
+    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
+    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
+  };
+
+  static void subBytes(State& s){
+    for(int i=0;i<4;++i) for(int j=0;j<4;++j) s[i][j]=s_box[s[i][j]];
+  }
+  static void shiftRows(State& s){
+    uint8_t t=s[1][0]; s[1][0]=s[1][1]; s[1][1]=s[1][2]; s[1][2]=s[1][3]; s[1][3]=t;
+    std::swap(s[2][0],s[2][2]); std::swap(s[2][1],s[2][3]);
+    t=s[3][3]; s[3][3]=s[3][2]; s[3][2]=s[3][1]; s[3][1]=s[3][0]; s[3][0]=t;
+  }
+  static void mixColumns_sim(State& s){
+    for(int j=0;j<4;++j){ uint8_t a=s[0][j],b=s[1][j],c=s[2][j],d=s[3][j];
+      s[0][j]=a^b^c; s[1][j]=b^c^d; s[2][j]=c^d^a; s[3][j]=d^a^b; }
+  }
+  static void addRoundKey(State& s,const Key& k){
+    for(int i=0;i<4;++i) for(int j=0;j<4;++j) s[j][i]^=k[i*4+j];
+  }
+
+  axim_mmio_device_t::Otp encryptBlock(const Key& key, const axim_mmio_device_t::Otp& pt){
+    State st;
+    for(int i=0;i<16;++i) st[i%4][i/4]=pt[i];
+    addRoundKey(st,key);
+    const int R=4;
+    for(int r=0;r<R;++r){ subBytes(st); shiftRows(st); if(r<R-1) mixColumns_sim(st); addRoundKey(st,key); }
+    axim_mmio_device_t::Otp ct;
+    for(int i=0;i<16;++i) ct[i]=st[i%4][i/4];
+    return ct;
+  }
+
+  static constexpr Key m_hardware_key = {
+    0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
+    0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
+  };
+
+  // --- メンバ ---
+  sim_t* sim;
+  axim_mmio_device_t* m_mod;
+
+  std::array<uint8_t,64> m_input_data{};
+  uint64_t m_start_reg = 0;  // 0:idle / 1:busy
+  int      m_block_idx = 0;  // 次に処理する 16B ブロック(0..3)
+};
+
diff --git a/riscv/mmio_devices/axim_device.h b/riscv/mmio_devices/axim_device.h
new file mode 100644
index 00000000..781e7a78
--- /dev/null
+++ b/riscv/mmio_devices/axim_device.h
@@ -0,0 +1,172 @@
+#pragma once
+#include "devices.h"
+#include "sim.h"
+#include "mmio_map.h"
+#include <vector>
+#include <cstring>
+#include <cstdint>
+#include <algorithm>
+#include <queue>
+#include <array>
+#include <functional>
+class axim_mmio_device_t final : public abstract_device_t {
+public:
+  axim_mmio_device_t(sim_t* sim, spm_device_t* spm)
+  : sim(sim), spm(spm) { }
+
+    // AESからOTPを受け取るための型定義
+    using Otp = std::array<uint8_t, 16>; // 128bit
+    using DataBlock = std::array<uint8_t, 64>; // 512bit
+     using ReadResponseCallback = std::function<void(const DataBlock&)>;
+    using WriteResponseCallback = std::function<void(bool)>;
+    struct LlcRequest {
+        bool is_write; // true: write, false: read
+        uint64_t addr;
+        uint64_t id; // 識別用ID
+        DataBlock data; // write時のデータ
+        ReadResponseCallback read_cb; // read完了時コールバック
+        WriteResponseCallback write_cb; // write完了時コールバック
+    };
+    void pushOtpToFifo(const Otp& otp) {
+        m_otp_fifo.push(otp);
+    }
+    void receiveLlcReadRequest(uint64_t addr, uint64_t id, ReadResponseCallback cb) {
+        m_request_queue.push({false, addr, id, {}, cb, nullptr});
+        // std::cout << "[AXIM] Read Request Queued (Addr: 0x" << std::hex << addr << ").\n" << std::dec;
+    }
+
+    void receiveLlcWriteRequest(uint64_t addr, uint64_t id, const DataBlock& data, WriteResponseCallback cb) {
+        m_request_queue.push({true, addr, id, data, nullptr, cb});
+        std::cout << "[AXIM] Write Request Queued (Addr: 0x" << std::hex << addr << ").\n" << std::dec;
+        // w_data_bufferにデータをセット
+        m_w_buffer = data;
+        return;
+    }
+reg_t size() override { return axim_addrmap_t::CTRL_SIZE; }
+
+    // MMIO read
+    bool load(reg_t addr, size_t len, uint8_t* bytes) override {
+        // std::cout << "[AXIM HW] MMIO Load from addr 0x" << std::hex << addr << std::dec << "\n";
+        if (len != 8) return false;
+        uint64_t v = 0;
+
+        switch (addr) {
+            case axim_addrmap_t::STATUS: {
+                uint64_t status = 0;
+                if (!m_request_queue.empty()) {
+                    status |= 1; // bit 0: キューにリクエストあり
+                    if (m_request_queue.front().is_write) {
+                        status |= 2; // bit 1: Writeリクエスト
+                    }
+                }
+            v = status;
+            break;
+            }
+            case axim_addrmap_t::REQ_ADDR:{
+                v = m_request_queue.empty() ? 0 : m_request_queue.front().addr;
+                break;
+            }
+            case axim_addrmap_t::REQ_ID:{
+                v = m_request_queue.empty() ? 0 : m_request_queue.front().id;
+                break;
+            }
+            case axim_addrmap_t::BUSY:{
+                v = m_busy_reg;
+                break;
+            }
+            default: return false; // 他は読み不可
+        }
+        std::memcpy(bytes, &v, 8);
+        return true;
+    }
+    bool store(reg_t addr, size_t len, const uint8_t* bytes) override {
+        if (len != 8) return false;
+        uint64_t v; std::memcpy(&v, bytes, 8);
+        if (addr == axim_addrmap_t::SPM_ADDR) {
+            m_spm_addr_reg = v;
+        } else if (addr == axim_addrmap_t::COMMAND) {
+            if (m_busy_reg == 0) {
+                executeCommand(v);
+            }
+        } else {
+            return false; // 他は書き不可
+        }
+        return true;
+    }
+
+private:
+    void executeCommand(uint64_t command) {
+        m_busy_reg = 1;
+        if (command & 1) { // Data Write Back (W Buffer -> SPM)
+            spm->write_back_local(m_spm_addr_reg, m_w_buffer.data());
+        }
+        if (command & 2) { // Data Copy (SPM -> R Buffer)
+            spm->copy_local(m_spm_addr_reg, m_r_buffer.data());
+            // for (size_t i = 0; i < m_r_buffer.size(); ++i) {
+            //     std::cout << std::hex << static_cast<int>(m_r_buffer[i]) << " ";
+            // }
+            // std::cout << std::dec << "\n";
+        }
+        if (command & 4) { // 暗号化 (OTP xor W Buffer)
+            // 暗号化する前のw_bufferをprint
+            for (size_t j = 0; j < 4; ++j) { // 64Bを16Bずつ4回に分けて処理
+                // OTPが足りない場合はスキップ
+                if (!m_otp_fifo.empty()) {
+                    auto otp_part = m_otp_fifo.front(); m_otp_fifo.pop();
+                    for(size_t i=0; i<16; ++i) m_w_buffer[16*j+i] ^= otp_part[i];
+                } else {
+                    std::cout << "  [AXIM HW] Warning: OTP FIFO empty during encryption.\n";
+                    exit(1);
+                }
+            }
+            if (!m_otp_fifo.empty()) {
+                std::cout << "  [AXIM HW] Warning: OTP FIFO not empty after decryption.\n";
+                exit(1);
+            }
+        }
+        if (command & 8) { // 復号化 (OTP xor R Buffer)
+            for (size_t j = 0; j < 4; ++j) { // 64Bを16Bずつ4回に分けて処理
+                if (!m_otp_fifo.empty()) {
+                    auto otp_part = m_otp_fifo.front(); m_otp_fifo.pop();
+                    // 
+                    for(size_t i=0; i<16; ++i) m_r_buffer[j*16+i] ^= otp_part[i];
+
+                } else {
+                    std::cout << "  [AXIM HW] Warning: OTP FIFO empty during decryption.\n";
+                    exit(1);
+                }
+            }
+            if (!m_otp_fifo.empty()) {
+                std::cout << "  [AXIM HW] Warning: OTP FIFO not empty after decryption.\n";
+                exit(1);
+            }
+
+        }
+        if (command & 16) { // Read Response (R Buffer -> LLC)
+            if (!m_request_queue.empty() && !m_request_queue.front().is_write) {
+                auto req = m_request_queue.front(); m_request_queue.pop();
+                if(req.read_cb) req.read_cb(m_r_buffer);
+            }
+        }
+        if (command & 32) { // Write Response (ACK -> LLC)
+            if (!m_request_queue.empty() && m_request_queue.front().is_write) {
+                auto req = m_request_queue.front(); m_request_queue.pop();
+                if(req.write_cb) req.write_cb(true); // 常に成功を返す
+            }
+        }
+        m_busy_reg = 0;
+    }
+
+    sim_t* sim;
+    spm_device_t* spm;   // ★ SPM実体への生ポインタ（または参照/unique_ptr等）
+
+    // --- 内部状態 ---
+    std::queue<LlcRequest> m_request_queue;
+    std::queue<Otp> m_otp_fifo;
+    DataBlock m_r_buffer{}; // Read Buffer
+    DataBlock m_w_buffer{}; // Write Buffer
+    
+    // MMIOレジスタの状態
+    uint64_t m_spm_addr_reg = 0;
+    uint64_t m_busy_reg = 0;
+};
diff --git a/riscv/mmio_devices/mac_device.h b/riscv/mmio_devices/mac_device.h
new file mode 100644
index 00000000..9937b16b
--- /dev/null
+++ b/riscv/mmio_devices/mac_device.h
@@ -0,0 +1,117 @@
+#pragma once
+#include "devices.h"
+#include "sim.h"
+#include "mmio_map.h"
+#include <vector>
+#include <cstring>
+#include <cstdint>
+#include <algorithm>
+class mac_mmio_device_t final : public abstract_device_t {
+public:
+  mac_mmio_device_t(sim_t* sim, spm_device_t* spm)
+  : sim(sim), spm(spm) { reset_state(); }
+
+reg_t size() override { return mac_addrmap_t::CTRL_SIZE; }
+    // MMIO read
+    bool load(reg_t addr, size_t len, uint8_t* bytes) override {
+        if (len != 8) return false;
+        uint64_t v = 0;
+        switch (addr) {
+            case mac_addrmap_t::REG_SPM_START : v = busy ? 1ULL : 0ULL; break;
+            case mac_addrmap_t::REG_STATUS:      v = status;      break;
+            case mac_addrmap_t::REG_MAC_RESULT:  v = mac;  break;
+            default: return false; // 他は読み不可
+        }
+        std::memcpy(bytes, &v, 8);
+        return true;
+    }
+    bool store(reg_t addr, size_t len, const uint8_t* bytes) override {
+        if (len != 8) return false;
+        uint64_t v; std::memcpy(&v, bytes, 8);
+        switch (addr) {
+            case mac_addrmap_t::REG_SPM_ADDR:   spm_addr = v;   return true;
+            case mac_addrmap_t::REG_SPM_START:
+                start = v;
+                if ((v & 1ULL) && !busy) start_dma();
+                start = 0;
+                return true;
+            case mac_addrmap_t::REG_COMMAND:    {
+                command = v;
+                if (command == 1 && !busy) reset_state(); // MAC演算
+                else if (command == 2 && !busy) update();
+                else if (command == 4 && !busy) return true; // NOP
+                else return false;
+                return true;
+            }
+            case mac_addrmap_t::REG_START_BIT:  start_bit = v;  return true;
+            case mac_addrmap_t::REG_END_BIT:    end_bit = v;    return true;
+            default: return false; // 他は書き不可
+        }
+    }
+
+private:
+    // FNV-1aハッシュ用の定数 (64bit版)
+    static constexpr uint64_t FNV_PRIME = 0x100000001b3;
+    static constexpr uint64_t FNV_OFFSET_BASIS = 0xcbf29ce484222325;
+    void start_dma() {
+        busy = true; 
+        // SPM範囲チェック
+        // if (!spm || (spm_addr + sizeof(buffer) > spm->capacity())) {
+        // err_dma = true; busy = false; return;
+        // }
+        // ★ busを通さず SPM から直接コピー
+        if (spm->copy_local(spm_addr, buffer)) {
+            busy = false;
+            return;
+        } 
+    }
+
+  void reset_state(){
+    spm_addr = 0;
+    command = 0;
+    start_bit = 0;
+    end_bit = 0;
+    mac = 0;
+    busy = false;
+    status = 0;
+  }
+  // FOV-1aのMAC演算  (64bit)
+  void update(){
+    uint64_t start_byte = start_bit / 8;
+    uint64_t end_byte = (end_bit) / 8;
+    status = 1;
+    if (end_byte >= 64 || start_byte > end_byte) {
+        //  std::cout << "  [Hash HW] ERROR: Invalid bit range.\n";
+    } else {
+        // FNV-1aアルゴリズムをそのバイト範囲で実行
+        // std::cout << "[Hash HW] Computing MAC from bit " << start_bit << " to " << end_bit << " (bytes " << start_byte << " to " << end_byte << ")\n";
+        // std::cout << "  Data: ";
+        // for (uint64_t i = start_byte; i <= end_byte; ++i) {
+        //     std::cout << std::hex << static_cast<int>(buffer[i]) << " ";
+        // }
+        // std::cout << std::dec << "\n";
+        for (uint64_t i = start_byte; i <= end_byte; ++i) {
+            mac ^= buffer[i];
+            mac *= FNV_PRIME;
+        }
+    }
+    status = 0;
+  }
+
+  sim_t* sim;
+  spm_device_t* spm;   // ★ SPM実体への生ポインタ（または参照/unique_ptr等）
+  uint8_t buffer[64];
+
+  // レジスタ影
+        uint64_t spm_addr  = 0;   // SPMローカルオフセット
+        uint64_t start_bit = 0;   // 0..511
+        uint64_t end_bit   = 0;   // 0..511
+        uint64_t mac       = 0;   // MAC_RESULT
+        uint64_t command   = 0;   // 1=INIT, 2=UPDATE, 4=NOP
+        uint64_t start     = 0;   // SPM_START
+        uint64_t status = 0;
+    // ステータス
+  bool busy      = false;
+
+  // 以降は前回と同じ（start_bit/end_bit/mac/statusなど）
+};
diff --git a/riscv/mmio_devices/memreq_device.h b/riscv/mmio_devices/memreq_device.h
new file mode 100644
index 00000000..6fb8a7f3
--- /dev/null
+++ b/riscv/mmio_devices/memreq_device.h
@@ -0,0 +1,222 @@
+#pragma once
+#include "devices.h"
+#include "sim.h"
+#include "mmio_map.h"
+#include <vector>
+#include <cstring>
+#include <cstdint>
+#include <algorithm>
+#include <iostream>
+#include <cstring>
+#include <random>
+#include <map>
+#include <queue>
+#include <functional>
+
+
+/*
+  memreq_device: AXI Master Interfaceを持ち、メモリに対してRead/Writeリクエストを発行する
+  - AXI Master Interfaceはaxim_mmio_device_tを通じて接続される
+  - レジスタインターフェースはmemreq_addrmap_tで定義される
+    - MEM_SIZE (0x00, W): メモリサイズ(Byte単位)
+    - NUM      (0x08, W): 転送回数(64B単位)
+  - 動作:
+    - NUMに値が書き込まれると、MEM_SIZEの範囲内でランダムに64Bアラインされたアドレスを選び、
+      そのアドレスに対してNUM回のWriteリクエストを発行し、その後同じアドレスに対してReadリクエストを発行する。
+    - 各Writeリクエストには簡単なデータパターンを書き込む。
+    - Readリクエストの応答が返ってきたら、書き込んだデータと比較し、一致すれば成功、不一致なら失敗とカウントする。
+    - 全てのReadリクエストの応答を受け取ったら、成功/失敗の集計結果を表示し、シミュレーションを終了する。
+  - Spikeからはtick()が周期的に呼ばれ、ここで1件ずつリクエストを発行していく。
+*/
+
+class memreq_mmio_device_t final : public abstract_device_t {
+public:
+  memreq_mmio_device_t(sim_t* sim, axim_mmio_device_t* axim)
+  : sim(sim), axim(axim) { }
+      // テスト操作を定義する内部構造体
+    struct TestOp {
+        enum class Type { Read, Write };
+        Type type;
+        uint64_t addr;
+        axim_mmio_device_t::DataBlock data; // Write時は書き込みデータ, Read時は期待データ
+    };
+    reg_t size() override { return memreq_addrmap_t::CTRL_SIZE; }
+    // MMIO read
+    bool load(reg_t addr, size_t len, uint8_t* bytes) override {
+        return false; // 読み不可
+    }
+    bool store(reg_t addr, size_t len, const uint8_t* bytes) override {
+        if (len != 8) return false;
+        uint64_t v; std::memcpy(&v, bytes, 8);
+        switch (addr) {
+            case memreq_addrmap_t::MEM_SIZE:  mem_size = v;   return true;
+            case memreq_addrmap_t::NUM:       {
+                num = v;
+                make_request(); 
+                state = State::ISSUING;
+                return true;
+            }
+            default: return false; // 他は書き不可
+        }
+    }
+    // ★ Spike が周期的に呼ぶ：ここで1件ずつ発行していく
+  void tick(reg_t /*rtc_ticks*/) override {
+    switch (state) {
+      case State::IDLE:
+        return;
+      case State::ISSUING: {
+        if (inflight) return; // 応答待ち中なら何もしない
+        // 未発行＆キューが空 → outstanding も空ならDONEへ
+        if (m_test_queue.empty()) {
+          if (m_outstanding_requests.empty()) {
+            state = State::DONE;
+          }
+          return;
+        }
+        // リクエスト発行
+        // issue_some_requests(REQUESTS_PER_TICK);
+        // 次の1件だけ発行
+        TestOp op = m_test_queue.front(); m_test_queue.pop();
+        uint64_t req_id = issue_idx + 1;
+        inflight = true;
+        m_outstanding_requests[req_id] = op;
+
+        std::cout << "[MEMREQ] issue id=" << req_id
+                  << " addr=0x" << std::hex << op.addr << std::dec
+                  << (op.type == TestOp::Type::Write ? " (W)\n" : " (R)\n");
+
+        if (op.type == TestOp::Type::Write) {
+          axim->receiveLlcWriteRequest(
+            op.addr, req_id, op.data,
+            [this, req_id](bool ok){ onWriteAck(req_id, ok); }
+          );
+        } else {
+          axim->receiveLlcReadRequest(
+            op.addr, req_id,
+            [this, req_id](const axim_mmio_device_t::DataBlock& data){
+              onReadResponse(req_id, data);
+            }
+          );
+        }
+        issue_idx++;
+        return;
+    }
+
+      case State::DONE:
+        if (m_outstanding_requests.empty()) {
+          std::cout << "[MEMREQ] all responses received.\n";
+          std::cout << "[MEMREQ] Passed: " << m_passed_count << ", Failed: " << m_failed_count << "\n";
+          state = State::IDLE; // 再度IDLEに戻す
+          exit(0); // テスト終了
+        }
+        return;
+    }
+}
+
+private:
+    enum class State { IDLE, ISSUING, DONE };
+    // テストシナリオをキューに追加
+    void addWriteTest(uint64_t addr, const axim_mmio_device_t::DataBlock& data) {
+        m_test_queue.push({ TestOp::Type::Write, addr, data });
+    }
+    void addReadTest(uint64_t addr, const axim_mmio_device_t::DataBlock& expected_data) {
+        m_test_queue.push({ TestOp::Type::Read, addr, expected_data });
+    }
+    void make_request(){
+        std::random_device rd;
+        std::mt19937 gen(rd());
+        std::uniform_int_distribution<uint32_t> addr_dist(0, mem_size / 64 - 1); // 64Bアラインされたアドレス範囲
+        std::cout << "\n[TB] Generating " << num << " test cases...\n";
+        {
+          std::vector<std::pair<uint64_t, axim_mmio_device_t::DataBlock>> test_plan;
+          for (uint64_t i = 0; i < num; ++i) {
+            uint64_t addr = addr_dist(gen) * 64 + 0x90000000;
+            axim_mmio_device_t::DataBlock data;
+            for(size_t j=0; j<data.size(); ++j) data[j] = i+j; // 簡単なデータパターン
+            test_plan.push_back({addr, data});
+            final_memory_state[addr] = data; // 最終的にこのアドレスにはこのデータがあるはず
+          }
+          // write
+          for (const auto& test_case : test_plan) {
+              addWriteTest(test_case.first, test_case.second);
+          }
+          // read
+          for (const auto& test_case : test_plan) {
+              addReadTest(test_case.first, final_memory_state[test_case.first]);
+          }
+        }
+        {
+          std::vector<std::pair<uint64_t, axim_mmio_device_t::DataBlock>> test_plan;
+          for (uint64_t i = 0; i < num; ++i) {
+            uint64_t addr = addr_dist(gen) * 64 + 0x90000000;
+            axim_mmio_device_t::DataBlock data;
+            for(size_t j=0; j<data.size(); ++j) data[j] = i+j; // 簡単なデータパターン
+            test_plan.push_back({addr, data});
+            final_memory_state[addr] = data; // 最終的にこのアドレスにはこのデータがあるはず
+          }
+          // write
+          for (const auto& test_case : test_plan) {
+              addWriteTest(test_case.first, test_case.second);
+          }
+          // read
+          for (const auto& test_case : test_plan) {
+              addReadTest(test_case.first, final_memory_state[test_case.first]);
+          }
+        }
+        total_expected_reqs = m_test_queue.size(); // ★ここで総数を確定
+    }
+    // Writeリクエストのコールバック
+    void onWriteAck(uint64_t req_id, bool success) {
+        std::cout << "[TB] Write Ack received for ID " << req_id << ".\n";
+        if (success) {
+            m_passed_count++;
+        } else {
+            m_failed_count++;
+        }
+        m_outstanding_requests.erase(req_id);
+        inflight = false;
+    }
+
+    // Readリクエストのコールバック
+    void onReadResponse(uint64_t req_id, const axim_mmio_device_t::DataBlock& received_data) {
+        std::cout << "[TB] Read Response received for ID " << req_id << ".\n";
+        auto it = m_outstanding_requests.find(req_id);
+        if (it != m_outstanding_requests.end()) {
+            if (it->second.data == received_data) {
+                std::cout << "  ✅ Data matches expected value.\n";
+                m_passed_count++;
+            } else {
+                std::cout << "  ❌ Data MISMATCH!\n";
+                std::cout << "  Expected: ";
+                for (const auto& byte : it->second.data) {
+                    std::cout << std::hex << static_cast<int>(byte) << " ";
+                }
+                std::cout << "\n  Received: ";
+                for (const auto& byte : received_data) {
+                    std::cout << std::hex << static_cast<int>(byte) << " ";
+                }
+                std::cout << std::dec << "\n";
+                m_failed_count++;
+            }
+            m_outstanding_requests.erase(it);
+            inflight = false;
+        }
+    }
+    sim_t* sim;
+    axim_mmio_device_t* axim;
+    // 発行ステート
+    State state = State::IDLE;
+
+    std::map<uint64_t, axim_mmio_device_t::DataBlock> final_memory_state; // 期待される最終メモリ状態
+    size_t issue_idx = 0;
+    static constexpr size_t REQUESTS_PER_TICK = 4; // 1 tickあたりの発行数
+    std::queue<TestOp> m_test_queue;
+    std::map<uint64_t, TestOp> m_outstanding_requests;
+    // レジスタ影
+    uint64_t num = 0;         // 転送回数
+    uint64_t mem_size = 0; // Byte単位
+    int m_passed_count = 0;
+    int m_failed_count = 0;
+    uint64_t total_expected_reqs = 0;
+    bool inflight = false; // 応答待ち中か
+};
diff --git a/riscv/mmio_devices/mmio_map.h b/riscv/mmio_devices/mmio_map.h
new file mode 100644
index 00000000..584fa4fd
--- /dev/null
+++ b/riscv/mmio_devices/mmio_map.h
@@ -0,0 +1,65 @@
+#pragma once
+#include <cstdint>
+struct spm_addrmap_t {
+  static constexpr uint64_t BASE         = 0x40000000ULL;
+  static constexpr uint64_t CTRL_SIZE    = 0x00001000ULL; // 4 KiB
+  static constexpr uint64_t MEM_SIZE     = 0x00010000ULL; // 64 KiB
+  static constexpr uint64_t TOTAL_SIZE   = CTRL_SIZE + MEM_SIZE;
+
+  // 64-bit レジスタオフセット（BASE からの相対）
+  static constexpr uint64_t REG_DRAM_ADDR  = 0x00;
+  static constexpr uint64_t REG_LOCAL_ADDR = 0x08; // SPMデータ窓先頭からのバイトオフセット
+  static constexpr uint64_t REG_SIZE       = 0x10;
+  static constexpr uint64_t REG_DIRECTION  = 0x18; // 0/1
+  static constexpr uint64_t REG_START      = 0x20; // write 1 to start / read busy
+  static constexpr uint64_t REG_STATUS     = 0x28;
+
+  // SPMデータ窓の開始
+  static constexpr uint64_t MEM_BASE_OFF   = CTRL_SIZE;
+};
+struct mac_addrmap_t {
+    static constexpr uint64_t BASE         = 0x50000000ULL;
+    static constexpr uint64_t CTRL_SIZE    = 0x00001000ULL; // 4 KiB
+
+    // 64bit レジスタオフセット（BASE からの相対）
+    static constexpr uint64_t REG_SPM_ADDR = 0x00;
+    static constexpr uint64_t REG_SPM_START = 0x08;
+    static constexpr uint64_t REG_COMMAND = 0x10;
+    static constexpr uint64_t REG_STATUS = 0x18;
+    static constexpr uint64_t REG_START_BIT = 0x20;
+    static constexpr uint64_t REG_END_BIT = 0x28;
+    static constexpr uint64_t REG_MAC_RESULT = 0x30;
+};
+struct aes_addrmap_t {
+    static constexpr uint64_t BASE = mac_addrmap_t::BASE + mac_addrmap_t::CTRL_SIZE;
+    static constexpr uint64_t CTRL_SIZE = 0x00001000ULL; // 4 KiB
+    // 64bit レジスタオフセット（BASE からの相対）
+    static constexpr uint64_t REG_INPUT_0 = 0x00;
+    static constexpr uint64_t REG_INPUT_1 = 0x08;
+    static constexpr uint64_t REG_INPUT_2 = 0x10;
+    static constexpr uint64_t REG_INPUT_3 = 0x18;
+    static constexpr uint64_t REG_INPUT_4 = 0x20;
+    static constexpr uint64_t REG_INPUT_5 = 0x28;
+    static constexpr uint64_t REG_INPUT_6 = 0x30;
+    static constexpr uint64_t REG_INPUT_7 = 0x38;
+    static constexpr uint64_t REG_START = 0x40;
+};
+struct axim_addrmap_t {
+    static constexpr uint64_t BASE = aes_addrmap_t::BASE + aes_addrmap_t::CTRL_SIZE;
+    static constexpr uint64_t CTRL_SIZE = 0x00001000ULL; // 4 KiB
+
+    // 64bit レジスタオフセット（BASE からの相対）
+    static constexpr uint64_t STATUS = 0x00;
+    static constexpr uint64_t REQ_ADDR = 0x08;
+    static constexpr uint64_t REQ_ID = 0x10;
+    static constexpr uint64_t SPM_ADDR = 0x18;
+    static constexpr uint64_t COMMAND = 0x20;
+    static constexpr uint64_t BUSY = 0x28;
+};
+struct memreq_addrmap_t {
+    static constexpr uint64_t BASE = axim_addrmap_t::BASE + axim_addrmap_t::CTRL_SIZE;
+    static constexpr uint64_t CTRL_SIZE = 0x00001000ULL; // 4 KiB
+    // 制御レジスタオフセット（BASE からの相対）
+    static constexpr uint64_t MEM_SIZE = 0x00; // メモリを保護する領域、スタートは0x9000_0000
+    static constexpr uint64_t NUM = 0x08; // 何個のリクエスト(=テストケース)を作るか
+};
\ No newline at end of file
diff --git a/riscv/mmio_devices/spm_device.h b/riscv/mmio_devices/spm_device.h
new file mode 100644
index 00000000..69948de9
--- /dev/null
+++ b/riscv/mmio_devices/spm_device.h
@@ -0,0 +1,152 @@
+#pragma once
+#include "devices.h"
+#include "sim.h"
+#include "mmio_devices/mmio_map.h"
+#include <vector>
+#include <cstring>
+#include <cstdint>
+#include <algorithm>
+
+
+
+class spm_device_t final : public abstract_device_t {
+public:
+  spm_device_t(sim_t* sim)
+  : sim(sim), spm_buf(spm_addrmap_t::MEM_SIZE, 0) {}
+
+  reg_t size() override { return spm_addrmap_t::TOTAL_SIZE; }
+
+  // MMIO read
+  bool load(reg_t addr, size_t len, uint8_t* bytes) override {
+    if (addr < spm_addrmap_t::CTRL_SIZE) {
+      // レジスタ空間（64bitのみ許可）
+      if (len != 8) return false;
+      uint64_t v = 0;
+      switch (addr) {
+        case spm_addrmap_t::REG_DRAM_ADDR:  v = dram_addr;  break;
+        case spm_addrmap_t::REG_LOCAL_ADDR: v = local_addr; break;
+        case spm_addrmap_t::REG_SIZE:       v = xfer_size;  break;
+        case spm_addrmap_t::REG_DIRECTION:  v = direction;  break;
+        case spm_addrmap_t::REG_START:      v = busy ? 1ULL : 0ULL; break;
+        case spm_addrmap_t::REG_STATUS:     v = status;     break;
+        default: return false;
+      }
+      std::memcpy(bytes, &v, 8);
+      return true;
+    } else {
+      // SPM データ窓
+      reg_t off = addr - spm_addrmap_t::MEM_BASE_OFF;
+      if (off + len > spm_buf.size()) return false;
+      std::memcpy(bytes, &spm_buf[off], len);
+      return true;
+    }
+  }
+
+  // MMIO write
+  bool store(reg_t addr, size_t len, const uint8_t* bytes) override {
+    if (addr < spm_addrmap_t::CTRL_SIZE) {
+      // レジスタ空間（64bitのみ許可）
+      if (len != 8) return false;
+      uint64_t v; std::memcpy(&v, bytes, 8);
+      switch (addr) {
+        case spm_addrmap_t::REG_DRAM_ADDR:  dram_addr  = v; return true;
+        case spm_addrmap_t::REG_LOCAL_ADDR: local_addr = v; return true; // SPM先頭からの相対
+        case spm_addrmap_t::REG_SIZE:       xfer_size  = v; return true;
+        case spm_addrmap_t::REG_DIRECTION:  direction  = v & 1ULL; return true;
+        case spm_addrmap_t::REG_START:
+          if ((v & 1ULL) && !busy) start_dma();
+          return true;
+        default: return false;
+      }
+    } else {
+      // SPM データ窓
+      reg_t off = addr - spm_addrmap_t::MEM_BASE_OFF;
+      if (off + len > spm_buf.size()) return false;
+      std::memcpy(&spm_buf[off], bytes, len);
+      return true;
+    }
+  }
+  void tick(reg_t /*rtc_ticks*/) override {
+    // 同期完了版：何もしない
+    // 非同期にしたいなら busy=true の間ここで少しずつ copy して最後に busy=false
+  }
+//  サイズは64B固定  
+  bool copy_local(uint64_t local_off, uint8_t* buf){
+    if (local_off + 64 > spm_buf.size()) return false;
+    std::memcpy(buf, &spm_buf[local_off], 64);
+    return true;
+  }
+  bool write_back_local(uint64_t local_off, const uint8_t* buf){
+    if (local_off + 64 > spm_buf.size()) return false;
+    std::memcpy(&spm_buf[local_off], buf, 64);
+    return true;
+  }
+
+private:
+  void start_dma() {
+    busy = true;
+    status = 0;
+
+    // local_addr は SPMデータ窓の先頭からのバイトオフセット（相対）
+    if (local_addr + xfer_size > spm_buf.size()) {
+      status |= 1ULL; // ERR_OOB
+      busy = false;
+      return;
+    }
+
+    bool ok = (direction == 0)
+      ? copy_dram_to_spm(dram_addr, local_addr, xfer_size)
+      : copy_spm_to_dram(local_addr, dram_addr, xfer_size);
+
+    if (!ok) status |= (1ULL << 1); // ERR_BUS
+    busy = false; // 完了
+  }
+
+  bool copy_dram_to_spm(reg_t src_pa, reg_t dst_spm_off, uint64_t len) {
+    reg_t pa = src_pa; reg_t off = dst_spm_off; uint64_t left = len;
+    while (left) {
+      if (left >= 8 && ((pa & 7) == 0) && ((off & 7) == 0)) {
+        uint8_t buf[8];
+        if (!sim->dma_read(pa, 8, buf)) return false;
+        std::memcpy(&spm_buf[off], buf, 8);
+        pa += 8; off += 8; left -= 8;
+      } else {
+        uint8_t b;
+        if (!sim->dma_read(pa, 1, &b)) return false;
+        spm_buf[off] = b;
+        pa += 1; off += 1; left -= 1;
+      }
+    }
+    return true;
+  }
+
+  bool copy_spm_to_dram(reg_t src_spm_off, reg_t dst_pa, uint64_t len) {
+    reg_t pa = dst_pa; reg_t off = src_spm_off; uint64_t left = len;
+    while (left) {
+      if (left >= 8 && ((pa & 7) == 0) && ((off & 7) == 0)) {
+        uint8_t buf[8];
+        std::memcpy(buf, &spm_buf[off], 8);
+        if (!sim->dma_write(pa, 8, buf)) return false;
+        pa += 8; off += 8; left -= 8;
+      } else {
+        uint8_t b = spm_buf[off];
+        if (!sim->dma_write(pa, 1, &b)) return false;
+        pa += 1; off += 1; left -= 1;
+      }
+    }
+    return true;
+  }
+
+private:
+  sim_t* sim;
+  std::vector<uint8_t> spm_buf;
+
+  // 64bitレジスタ
+  uint64_t dram_addr  = 0;
+  uint64_t local_addr = 0; // SPMデータ窓先頭からの相対（バイト）
+  uint64_t xfer_size  = 0;
+  uint64_t direction  = 0; // 0/1
+  uint64_t status     = 0;
+
+  bool busy = false;
+};
diff --git a/riscv/sim.cc b/riscv/sim.cc
index fb643d6f..fac12332 100644
--- a/riscv/sim.cc
+++ b/riscv/sim.cc
@@ -20,7 +20,12 @@
 #include <unistd.h>
 #include <sys/wait.h>
 #include <sys/types.h>
-
+#include "mmio_devices/spm_device.h"
+#include "mmio_devices/mac_device.h"
+#include "mmio_devices/mmio_map.h"
+#include "mmio_devices/axim_device.h"
+#include "mmio_devices/aes_device.h"
+#include "mmio_devices/memreq_device.h"
 volatile bool ctrlc_pressed = false;
 static void handle_signal(int sig)
 {
@@ -36,6 +41,8 @@ extern device_factory_t* clint_factory;
 extern device_factory_t* plic_factory;
 extern device_factory_t* ns16550_factory;
 
+constexpr reg_t DOUBLE_BASE = 0x40000000;
+
 sim_t::sim_t(const cfg_t *cfg, bool halted,
              std::vector<std::pair<reg_t, abstract_mem_t*>> mems,
              const std::vector<device_factory_sargs_t>& plugin_device_factories,
@@ -97,7 +104,24 @@ sim_t::sim_t(const cfg_t *cfg, bool halted,
 #endif
 
   debug_mmu = new mmu_t(this, cfg->endianness, NULL, cfg->cache_blocksz);
-
+  // 生成するのは、SPM, MAC,AES,AXIM,MemReq
+  // SPM 
+  auto spm = std::make_shared<spm_device_t>(this /*, 他サイズ等*/);
+  add_device(spm_addrmap_t::BASE, spm);          // 例: 0x5000_0000
+  // MAC
+  auto mac = std::make_shared<mac_mmio_device_t>(this, spm.get());
+  add_device(mac_addrmap_t::BASE, mac);
+  auto axim = std::make_shared<axim_mmio_device_t>(this, spm.get());
+  add_device(axim_addrmap_t::BASE, axim);
+  // AES
+  auto aes = std::make_shared<aes_mmio_device_t>(this, axim.get());
+  add_device(aes_addrmap_t::BASE, aes);
+  // MemReq
+  auto memreq = std::make_shared<memreq_mmio_device_t>(this, axim.get());
+  add_device(memreq_addrmap_t::BASE, memreq);
+  // Double device (for testing purpose)
+  // auto dbl = std::make_shared<double_device_t>();  // double_device_t::size()==0x1000 が使われる
+  // add_device(DOUBLE_BASE, dbl);
   // When running without using a dtb, skip the fdt-based configuration steps
   if (!dtb_enabled) {
     for (size_t i = 0; i < cfg->nprocs(); i++) {
@@ -470,3 +494,15 @@ void sim_t::proc_reset(unsigned id)
 {
   debug_module.proc_reset(id);
 }
+
+bool sim_t::dma_read(reg_t paddr, size_t len, uint8_t* bytes) {
+  if (paddr + len < paddr)
+    return false;
+  return bus.load(paddr, len, bytes);
+}
+
+bool sim_t::dma_write(reg_t paddr, size_t len, const uint8_t* bytes) {
+  if (paddr + len < paddr)
+    return false;
+  return bus.store(paddr, len, bytes);
+}
\ No newline at end of file
diff --git a/riscv/sim.h b/riscv/sim.h
index da04a882..9a8c84c9 100644
--- a/riscv/sim.h
+++ b/riscv/sim.h
@@ -63,11 +63,14 @@ public:
 
   // Callback for processors to let the simulation know they were reset.
   virtual void proc_reset(unsigned id) override;
+  bool dma_read(reg_t paddr, size_t len, uint8_t* bytes);
+  bool dma_write(reg_t paddr, size_t len, const uint8_t* bytes);
 
   static const size_t INTERLEAVE = 5000;
   static const size_t INSNS_PER_RTC_TICK = 100; // 10 MHz clock for 1 BIPS core
   static const size_t CPU_HZ = 1000000000; // 1GHz CPU
 
+
 private:
   const cfg_t * const cfg;
   std::vector<std::pair<reg_t, abstract_mem_t*>> mems;
