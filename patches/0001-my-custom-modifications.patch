diff --git a/riscv/sim.cc b/riscv/sim.cc
index fb643d6f..fac12332 100644
--- a/riscv/sim.cc
+++ b/riscv/sim.cc
@@ -20,7 +20,12 @@
 #include <unistd.h>
 #include <sys/wait.h>
 #include <sys/types.h>
-
+#include "mmio_devices/spm_device.h"
+#include "mmio_devices/mac_device.h"
+#include "mmio_devices/mmio_map.h"
+#include "mmio_devices/axim_device.h"
+#include "mmio_devices/aes_device.h"
+#include "mmio_devices/memreq_device.h"
 volatile bool ctrlc_pressed = false;
 static void handle_signal(int sig)
 {
@@ -36,6 +41,8 @@ extern device_factory_t* clint_factory;
 extern device_factory_t* plic_factory;
 extern device_factory_t* ns16550_factory;
 
+constexpr reg_t DOUBLE_BASE = 0x40000000;
+
 sim_t::sim_t(const cfg_t *cfg, bool halted,
              std::vector<std::pair<reg_t, abstract_mem_t*>> mems,
              const std::vector<device_factory_sargs_t>& plugin_device_factories,
@@ -97,7 +104,24 @@ sim_t::sim_t(const cfg_t *cfg, bool halted,
 #endif
 
   debug_mmu = new mmu_t(this, cfg->endianness, NULL, cfg->cache_blocksz);
-
+  // 生成するのは、SPM, MAC,AES,AXIM,MemReq
+  // SPM 
+  auto spm = std::make_shared<spm_device_t>(this /*, 他サイズ等*/);
+  add_device(spm_addrmap_t::BASE, spm);          // 例: 0x5000_0000
+  // MAC
+  auto mac = std::make_shared<mac_mmio_device_t>(this, spm.get());
+  add_device(mac_addrmap_t::BASE, mac);
+  auto axim = std::make_shared<axim_mmio_device_t>(this, spm.get());
+  add_device(axim_addrmap_t::BASE, axim);
+  // AES
+  auto aes = std::make_shared<aes_mmio_device_t>(this, axim.get());
+  add_device(aes_addrmap_t::BASE, aes);
+  // MemReq
+  auto memreq = std::make_shared<memreq_mmio_device_t>(this, axim.get());
+  add_device(memreq_addrmap_t::BASE, memreq);
+  // Double device (for testing purpose)
+  // auto dbl = std::make_shared<double_device_t>();  // double_device_t::size()==0x1000 が使われる
+  // add_device(DOUBLE_BASE, dbl);
   // When running without using a dtb, skip the fdt-based configuration steps
   if (!dtb_enabled) {
     for (size_t i = 0; i < cfg->nprocs(); i++) {
@@ -470,3 +494,15 @@ void sim_t::proc_reset(unsigned id)
 {
   debug_module.proc_reset(id);
 }
+
+bool sim_t::dma_read(reg_t paddr, size_t len, uint8_t* bytes) {
+  if (paddr + len < paddr)
+    return false;
+  return bus.load(paddr, len, bytes);
+}
+
+bool sim_t::dma_write(reg_t paddr, size_t len, const uint8_t* bytes) {
+  if (paddr + len < paddr)
+    return false;
+  return bus.store(paddr, len, bytes);
+}
\ No newline at end of file
